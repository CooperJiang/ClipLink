# 通道认证中间件实现文档

## 概述

为了增强系统安全性，我们实现了通道认证中间件，用于验证请求头中的`X-Channel-ID`是否合法。除了创建通道和验证通道的接口外，所有其他接口都需要提供有效的通道ID才能访问。

## 实现细节

### 1. 通道模型设计

在`internal/model/clipboard.go`中，我们已经有了`Channel`模型：

```go
// Channel 通道模型，用于访问隔离
type Channel struct {
    ID        string    `json:"id" gorm:"primarykey"` // 通道ID
    CreatedAt time.Time `json:"created_at"`           // 创建时间
}
```

### 2. 通道认证中间件

在`internal/middleware/channel_auth.go`中，我们创建了通道认证中间件：

```go
// ChannelAuthMiddleware 通道认证中间件，验证请求头中的X-Channel-ID是否合法
func ChannelAuthMiddleware(channelRepo repository.ChannelRepository, skipPaths []string) gin.HandlerFunc {
    return func(c *gin.Context) {
        // 获取完整路径
        fullPath := c.Request.URL.Path

        // 检查是否需要跳过验证
        for _, skipPath := range skipPaths {
            if strings.HasSuffix(fullPath, skipPath) {
                c.Next()
                return
            }
        }

        // 获取通道ID
        channelID := c.GetHeader("X-Channel-ID")
        if channelID == "" {
            response.Unauthorized(c, "请求头中缺少X-Channel-ID")
            c.Abort()
            return
        }

        // 验证通道ID是否存在
        exists, err := channelRepo.ChannelExists(channelID)
        if err != nil {
            response.ServerError(c, "验证通道ID失败: "+err.Error())
            c.Abort()
            return
        }

        if !exists {
            response.Unauthorized(c, "无效的通道ID")
            c.Abort()
            return
        }

        // 继续处理请求
        c.Next()
    }
}
```

### 3. 路由注册与中间件应用

在`internal/controller/routes.go`中，我们应用了通道认证中间件：

```go
// 定义需要跳过通道验证的路径
skipPaths := []string{
    "/channel",
    "/channel/verify",
}

// 通道相关路由 - 不需要通道ID验证
r.POST("/channel", channelController.CreateChannel)
r.POST("/channel/verify", channelController.VerifyChannel)

// 添加通道认证中间件，所有其他路由都需要验证通道ID
r.Use(middleware.ChannelAuthMiddleware(channelRepo, skipPaths))

// 其他路由 - 已经通过中间件验证通道ID...
```

## 工作流程

1. 客户端首先通过`POST /api/channel`创建一个通道，或通过`POST /api/channel/verify`验证一个已有的通道
2. 客户端在之后的所有请求中，都需要在请求头中添加`X-Channel-ID`字段
3. 中间件会拦截所有请求（除了创建通道和验证通道的请求），验证通道ID是否存在于数据库中
4. 如果通道ID不存在或未提供，返回401 Unauthorized错误
5. 如果通道ID有效，请求将传递给相应的控制器处理

## 安全性考虑

1. 通道ID应当保密，建议使用随机生成的字符串
2. 所有API（除了创建通道和验证通道）都必须验证通道ID，确保数据隔离
3. 401响应不会暴露系统中存在哪些通道ID
4. 通道验证不依赖于控制器逻辑，确保所有接口都经过验证

## 前端集成

前端应用需要做如下调整：

1. 通过创建通道接口获取通道ID，或要求用户提供通道ID并验证其有效性
2. 将通道ID保存在本地存储或会话中
3. 在所有请求中添加`X-Channel-ID`请求头
4. 处理401错误，在通道ID失效时引导用户重新验证或创建通道 